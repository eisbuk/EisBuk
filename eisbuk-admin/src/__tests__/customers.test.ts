import firebase from "firebase";

import {
  Category,
  Collection,
  Customer,
  CustomerBase,
  OrgSubCollection,
} from "eisbuk-shared";

import { adminDb } from "@/tests/settings";
import { ORGANIZATION } from "@/config/envInfo";

import { deleteAll } from "@/tests/utils";
import { waitForCondition, stripIdAndSecretKey } from "@/__testUtils__/helpers";
import { testWithEmulator } from "@/__testUtils__/envUtils";

import { saul } from "@/__testData__/customers";

type DocumentData = firebase.firestore.DocumentData;

afterEach(async () => {
  await deleteAll([OrgSubCollection.Customers, OrgSubCollection.Bookings]);
});

// string path to `customers` collection
const customersPath = `${Collection.Organizations}/${ORGANIZATION}/${OrgSubCollection.Customers}`;
// string path to `bookings` collection
const bookingsPath = `${Collection.Organizations}/${ORGANIZATION}/${OrgSubCollection.Bookings}`;

describe("Customer triggers", () => {
  testWithEmulator(
    "should apply secretKey and customerId (to customer structure) when a customer record is added",
    async () => {
      const customersRef = adminDb
        .collection(Collection.Organizations)
        .doc(ORGANIZATION)
        .collection(OrgSubCollection.Customers);
      // we're using saul's data only as newly created object (on `id` or `secretKey`)
      const newSaul = stripIdAndSecretKey(saul);
      // we're setting a customer entry without id to the database (as id's are generated serverside)
      await customersRef.doc().set(newSaul);
      // get newly generated id from db entry
      const customersSnapshot = await customersRef.get();
      const saulSnapshot = customersSnapshot.docs[0];
      const saulId = saulSnapshot.id;
      // get entire saul entry from customers snapshot
      const { id, secretKey, ...saulFromDB } =
        (await waitForCondition({
          documentPath: `${customersPath}/${saulId}`,
          condition: (data) => data && data.secretKey && data.id,
        })) || {};

      // expect id (the same as assigned doc.id) to be added within customer structure
      expect(id).toBe(saulId);
      expect(secretKey).toBeDefined();
      // expect the rest of the customer queried by id to be the same as the one set to db
      expect(saulFromDB).toEqual(newSaul);
    }
  );

  testWithEmulator(
    "should create bookings entry (for customer) when a customer record is created",
    async () => {
      const orgRef = adminDb
        .collection(Collection.Organizations)
        .doc(ORGANIZATION);
      const customersRef = orgRef.collection(OrgSubCollection.Customers);
      // we're testing customer creation as it would happen in the wild (no `id` and `secretKey`) initially
      const newSaul = stripIdAndSecretKey(saul);
      await customersRef.doc().set(saul);
      // get the server generated id for saul
      const saulId = (await customersRef.get()).docs[0].id;
      // wait for `secretKey` to be generated by the data trigger
      const { secretKey } = (await waitForCondition({
        documentPath: `${customersPath}/${saulId}`,
        condition: hasSecretKey,
      })) as Customer;
      // wait for customer entry to be added to `bookings` collection
      const bookingsEntry = await waitForCondition({
        documentPath: `${bookingsPath}/${secretKey}`,
        condition: (data) => Boolean(data),
      });
      // customer base structure of saul's data (for comparison)
      const saulBase = getCustomerBase({ ...newSaul, id: saulId });
      expect(bookingsEntry).toEqual(saulBase);
    }
  );

  testWithEmulator(
    "should update customer's 'bookings' entry when a customer record is updated",
    async () => {
      const orgRef = adminDb
        .collection(Collection.Organizations)
        .doc(ORGANIZATION);
      const saulRef = orgRef
        .collection(OrgSubCollection.Customers)
        .doc(saul.id);
      await saulRef.set(saul);
      // wait for `secretKey` to be created
      const { secretKey } = (await waitForCondition({
        documentPath: `${customersPath}/${saul.id}`,
        condition: hasSecretKey,
      })) as Customer;
      // wait for first round of `bookings` entry updates
      await waitForCondition({
        documentPath: `${bookingsPath}/${secretKey}`,
        condition: (data) => Boolean(data),
      });
      // add update to db
      const updatedCategory = Category.Course;
      const updatedSaul = { ...saul, secretKey, category: updatedCategory };
      await saulRef.set(updatedSaul);
      // check `bookings` entry updates
      await waitForCondition({
        documentPath: `${bookingsPath}/${secretKey}`,
        condition: (data) => Boolean(data && data.category === updatedCategory),
      });
    }
  );
});

/**
 * Check for secretKey in provided document.
 * Used to test `addMissingSecretKey` function for
 * customer registration
 * @param data document data
 * @returns whether secret key exists
 */
const hasSecretKey = (data: DocumentData | undefined) => {
  return data && data.secretKey;
};
/**
 * A helper function used to strip excess customer data
 * and create customer base data (used to test `booking` entry for customer)
 * @param customer customer entry (without `secretKey` for convenient testing)
 * @returns customer base structure
 */
const getCustomerBase = ({
  id,
  name,
  surname,
  category,
}: Omit<Customer, "secretKey">): CustomerBase => ({
  id,
  name,
  surname,
  category,
});
