/**
 * @vitest-environment node
 */

import { describe, expect } from "vitest";

import { Category, Customer, sanitizeCustomer } from "@eisbuk/shared";

import { saul } from "@eisbuk/testing/customers";

import { db as clientDb } from "@/__testSetup__/firestoreSetup";
import { setUpOrganization } from "@/__testSetup__/node";

import {
  getBookingsDocPath,
  getCustomerDocPath,
  getCustomersPath,
  getDoc,
  collection,
  doc,
  setDoc,
  getDocs,
  FirestoreVariant,
  addDoc,
} from "@/utils/firestore";

import { waitFor } from "@/__testUtils__/helpers";
import { stripIdAndSecretKey } from "@/__testUtils__/customers";
import { testWithEmulator } from "@/__testUtils__/envUtils";

const db = FirestoreVariant.client({ instance: clientDb });

describe("Customer triggers", () => {
  testWithEmulator(
    "should apply secretKey and customerId (to customer structure) when a customer record is added",
    async () => {
      const { organization } = await setUpOrganization();
      const customersCollRef = collection(db, getCustomersPath(organization));
      // we're using saul's data only as newly created object (on `id` or `secretKey`)
      const newSaul = stripIdAndSecretKey(saul);
      // we're setting a customer entry without id to the database (as id's are generated serverside)
      await addDoc(customersCollRef, newSaul);
      // get newly generated id from db entry
      const customersSnapshot = await getDocs(customersCollRef);
      const saulSnapshot = customersSnapshot.docs[0];
      const saulId = saulSnapshot.id;
      // get entire saul entry from customers snapshot
      await waitFor(async () => {
        const snap = await getDoc(
          doc(db, getCustomerDocPath(organization, saulId))
        );
        const { id, secretKey, ...saulFromDB } = snap.data() as Customer;
        // expect id (the same as assigned doc.id) to be added within customer structure
        expect(id).toBe(saulId);
        expect(secretKey).toBeDefined();
        // expect the rest of the customer queried by id to be the same as the one set to db
        expect(saulFromDB).toEqual(newSaul);
      });
    }
  );

  testWithEmulator(
    "should create bookings entry (for customer) when a customer record is created",
    async () => {
      const { organization } = await setUpOrganization();
      const customersCollRef = collection(db, getCustomersPath(organization));
      // we're testing customer creation as it would happen in the wild (no `id` and `secretKey`) initially
      // we're also adding an `extendedDate` to assure it gets copied over to `bookings` as well
      const extendedDate = "2022-01-01";
      const newSaul = { ...stripIdAndSecretKey(saul), extendedDate };
      const saulDocSnap = await addDoc(customersCollRef, {
        ...saul,
        extendedDate,
      });
      // get the server generated id for saul
      const saulId = saulDocSnap.id;
      // wait for `secretKey` to be generated by the data trigger
      const { secretKey } = await waitFor(async () => {
        const snap = await getDoc(
          doc(db, getCustomerDocPath(organization, saulId))
        );
        const data = snap.data() as Customer;
        expect(Boolean(data?.secretKey)).toEqual(true);
        return data;
      });
      // wait for customer entry to be added to `bookings` collection
      await waitFor(async () => {
        const snap = await getDoc(
          doc(db, getBookingsDocPath(organization, secretKey))
        );
        // customer base structure of saul's data (for comparison)
        expect(snap.data()).toEqual(
          sanitizeCustomer({
            ...newSaul,
            id: saulId,
            secretKey,
          })
        );
      });
    }
  );

  testWithEmulator(
    "should update customer's 'bookings' entry when a customer record is updated",
    async () => {
      const { organization } = await setUpOrganization();
      const saulDocRef = doc(db, getCustomerDocPath(organization, saul.id));
      await setDoc(saulDocRef, saul);
      // the existing `secretKey` should be used
      const { secretKey } = saul;
      // wait for first round of `bookings` entry updates
      await waitFor(async () => {
        const snap = await getDoc(
          doc(db, getBookingsDocPath(organization, secretKey))
        );
        expect(Boolean(snap.data())).toEqual(true);
      });
      // add update to db
      const updatedCategory = [Category.CourseAdults];
      const updatedSaul = {
        ...saul,
        secretKey,
        categories: updatedCategory,
        deleted: true,
      };
      await setDoc(saulDocRef, updatedSaul);

      // check `bookings` entry updates
      await waitFor(async () => {
        const snap = await getDoc(
          doc(db, getBookingsDocPath(organization, secretKey))
        );
        const data = snap.data();
        expect(
          Boolean(
            data &&
              updatedCategory.every((cat: Category) =>
                data.categories.includes(cat)
              ) &&
              data.deleted === true
          )
        ).toEqual(true);
      });
    }
  );
});
